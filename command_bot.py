#!/usr/bin/env python3
"""
–ü—Ä–æ—Å—Ç–æ–π –±–æ—Ç —Å –∫–æ–º–∞–Ω–¥–∞–º–∏
–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–∞–º —É–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ –¥–µ–ª–∞—Ç—å —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
"""

import logging
import asyncio
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler

from config import TELEGRAM_BOT_TOKEN
from audio_processor_fixed import AudioProcessorFixed
from apple_integration import AppleCalendarIntegration
from notion_integration import NotionPlanner

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class CommandTelegramBot:
    """–ü—Ä–æ—Å—Ç–æ–π –±–æ—Ç —Å –∫–æ–º–∞–Ω–¥–∞–º–∏"""
    
    def __init__(self):
        self.audio_processor = AudioProcessorFixed()
        self.calendar = AppleCalendarIntegration()
        self.notion = NotionPlanner()
        
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        welcome_message = """
ü§ñ *–ü—Ä–æ—Å—Ç–æ–π AI –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç —Å –∫–æ–º–∞–Ω–¥–∞–º–∏*

*–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:*

**–î–ª—è –∫–∞–ª–µ–Ω–¥–∞—Ä—è:**
‚Ä¢ "–î–æ–±–∞–≤—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å: –≤—Å—Ç—Ä–µ—á–∞ –∑–∞–≤—Ç—Ä–∞ –≤ 15:00"
‚Ä¢ "–ö–∞–ª–µ–Ω–¥–∞—Ä—å: –∑–≤–æ–Ω–æ–∫ –≤ 10:30"
‚Ä¢ "–í –∫–∞–ª–µ–Ω–¥–∞—Ä—å: —Å–æ–±—ã—Ç–∏–µ –≤ –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫ –≤ 14:00"

**–î–ª—è Notion:**
‚Ä¢ "–°–æ—Ö—Ä–∞–Ω–∏ –≤ notion: –∏–¥–µ—è –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞"
‚Ä¢ "Notion: –∑–∞–º–µ—Ç–∫–∞ –æ –≤–∞–∂–Ω–æ–º"
‚Ä¢ "–í notion: –ø–ª–∞–Ω –Ω–∞ –Ω–µ–¥–µ–ª—é"

**–ü—Ä–∏–º–µ—Ä—ã:**
‚Ä¢ "–î–æ–±–∞–≤—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å: —Ä–∞–∑–±–æ—Ä –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –≤ –ú–§–¶ 27.09 –≤ 10:00"
‚Ä¢ "–°–æ—Ö—Ä–∞–Ω–∏ –≤ notion: –∏–¥–µ—è —Å–æ–∑–¥–∞—Ç—å –º–æ–±–∏–ª—å–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ"

*–ü—Ä–æ—Å—Ç–æ —É–∫–∞–∂–∏, —á—Ç–æ –¥–µ–ª–∞—Ç—å —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π!* üöÄ
        """
        await update.message.reply_text(welcome_message, parse_mode='Markdown')
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        help_message = """
üìö *–ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞*

**üìÖ –ö–∞–ª–µ–Ω–¥–∞—Ä—å:**
‚Ä¢ "–¥–æ–±–∞–≤—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å: [—Å–æ–±—ã—Ç–∏–µ]"
‚Ä¢ "–∫–∞–ª–µ–Ω–¥–∞—Ä—å: [—Å–æ–±—ã—Ç–∏–µ]"
‚Ä¢ "–≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å: [—Å–æ–±—ã—Ç–∏–µ]"

**üìã Notion:**
‚Ä¢ "—Å–æ—Ö—Ä–∞–Ω–∏ –≤ notion: [–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è]"
‚Ä¢ "notion: [–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è]"
‚Ä¢ "–≤ notion: [–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è]"

**üé§ –ì–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è:**
‚Ä¢ –ó–∞–ø–∏—Å—ã–≤–∞–π –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å –∫–æ–º–∞–Ω–¥–æ–π
‚Ä¢ –ë–æ—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–µ—Ç –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç –¥–µ–π—Å—Ç–≤–∏–µ

**–ü—Ä–∏–º–µ—Ä—ã:**
‚Ä¢ "–î–æ–±–∞–≤—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å: –≤—Å—Ç—Ä–µ—á–∞ —Å –∫–ª–∏–µ–Ω—Ç–æ–º –∑–∞–≤—Ç—Ä–∞ –≤ 15:00"
‚Ä¢ "–°–æ—Ö—Ä–∞–Ω–∏ –≤ notion: –∏–¥–µ—è –¥–ª—è –Ω–æ–≤–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞"
‚Ä¢ "–ö–∞–ª–µ–Ω–¥–∞—Ä—å: –∑–≤–æ–Ω–æ–∫ –≤—Ä–∞—á—É –≤ –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫ –≤ 10:00"

*–í—Å–µ –ø—Ä–æ—Å—Ç–æ - —É–∫–∞–∑—ã–≤–∞–π –∫–æ–º–∞–Ω–¥—É –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é!* ‚ú®
        """
        await update.message.reply_text(help_message, parse_mode='Markdown')
    
    async def handle_audio_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle incoming audio/voice messages"""
        try:
            # Send processing message
            processing_msg = await update.message.reply_text("üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∞—É–¥–∏–æ—Å–æ–æ–±—â–µ–Ω–∏–µ...")
            
            # Extract text from audio
            text = await self.audio_processor.process_audio_message(update, context)
            
            if not text:
                await processing_msg.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å —Ç–µ–∫—Å—Ç –∏–∑ –∞—É–¥–∏–æ. –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑ —Å –±–æ–ª–µ–µ —á–µ—Ç–∫–æ–π —Ä–µ—á—å—é.")
                return
            
            # Check if text is an error message
            if any(text.startswith(error) for error in [
                "–ê—É–¥–∏–æ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ", "–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π", 
                "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç", "–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è",
                "‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è", "Whisper API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"
            ]):
                await processing_msg.edit_text(text, parse_mode='Markdown')
                return
            
            # Process the command
            await self._process_command(text, processing_msg, update.effective_user.id)
                
        except Exception as e:
            logger.error(f"Error handling audio message: {e}")
            await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∞—É–¥–∏–æ—Å–æ–æ–±—â–µ–Ω–∏—è.")
    
    async def handle_text_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle incoming text messages"""
        try:
            text = update.message.text
            
            # Skip if it's a command
            if text.startswith('/'):
                return
            
            # Process the command
            await self._process_command(text, update.message, update.effective_user.id)
                
        except Exception as e:
            logger.error(f"Error handling text message: {e}")
            await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è.")
    
    async def _process_command(self, text: str, message_obj, user_id: int):
        """Process command from text"""
        text_lower = text.lower()
        
        # Check for calendar commands
        calendar_keywords = ["–¥–æ–±–∞–≤—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å", "–∫–∞–ª–µ–Ω–¥–∞—Ä—å:", "–≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å"]
        for keyword in calendar_keywords:
            if keyword in text_lower:
                # Extract event text
                event_text = text[text.lower().find(keyword) + len(keyword):].strip()
                if event_text.startswith(':'):
                    event_text = event_text[1:].strip()
                
                await self._add_to_calendar(event_text, message_obj)
                return
        
        # Check for notion commands
        notion_keywords = ["—Å–æ—Ö—Ä–∞–Ω–∏ –≤ notion", "notion:", "–≤ notion"]
        for keyword in notion_keywords:
            if keyword in text_lower:
                # Extract content text
                content_text = text[text.lower().find(keyword) + len(keyword):].strip()
                if content_text.startswith(':'):
                    content_text = content_text[1:].strip()
                
                await self._add_to_notion(content_text, message_obj)
                return
        
        # If no command found, show help
        await message_obj.reply_text(
            "‚ùì –ù–µ –ø–æ–Ω—è–ª –∫–æ–º–∞–Ω–¥—É. –ò—Å–ø–æ–ª—å–∑—É–π:\n\n"
            "üìÖ **–ö–∞–ª–µ–Ω–¥–∞—Ä—å:** '–¥–æ–±–∞–≤—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å: [—Å–æ–±—ã—Ç–∏–µ]'\n"
            "üìã **Notion:** '—Å–æ—Ö—Ä–∞–Ω–∏ –≤ notion: [–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è]'\n\n"
            "–ü—Ä–∏–º–µ—Ä: '–î–æ–±–∞–≤—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å: –≤—Å—Ç—Ä–µ—á–∞ –∑–∞–≤—Ç—Ä–∞ –≤ 15:00'",
            parse_mode='Markdown'
        )
    
    async def _add_to_calendar(self, event_text: str, message_obj):
        """Add event to calendar"""
        try:
            # Try to extract time from text
            event_time = self._extract_time_from_text(event_text)
            
            result = await self.calendar.create_event(
                title=event_text,
                start_time=event_time,
                duration=60  # 1 hour default
            )
            
            if result.get("success", False):
                await message_obj.reply_text(
                    f"üìÖ **–°–û–ë–´–¢–ò–ï** –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ Apple Calendar!\n\n"
                    f"**–°–æ–±—ã—Ç–∏–µ:** {event_text}\n"
                    f"**–í—Ä–µ–º—è:** {event_time.strftime('%H:%M %d.%m.%Y')}",
                    parse_mode='Markdown'
                )
            else:
                await message_obj.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å: {result.get('error', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞')}")
                
        except Exception as e:
            logger.error(f"Error adding to calendar: {e}")
            await message_obj.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—å: {str(e)}")
    
    async def _add_to_notion(self, content_text: str, message_obj):
        """Add content to Notion"""
        try:
            result = await self.notion.create_material_entry(
                title=f"üìù {content_text[:50]}...",
                content=content_text,
                category="notes",
                tags=["–∑–∞–º–µ—Ç–∫–∞", "–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"]
            )
            
            if result:
                await message_obj.reply_text(
                    f"üìã **–ò–ù–§–û–†–ú–ê–¶–ò–Ø** —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ Notion!\n\n"
                    f"**–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ:** {content_text}",
                    parse_mode='Markdown'
                )
            else:
                await message_obj.reply_text("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ Notion")
                
        except Exception as e:
            logger.error(f"Error adding to Notion: {e}")
            await message_obj.reply_text(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ Notion: {str(e)}")
    
    def _extract_time_from_text(self, text: str):
        """Extract time from text"""
        import re
        from datetime import datetime, timedelta
        
        text_lower = text.lower()
        
        # Look for time patterns
        time_patterns = [
            r'(\d{1,2}):(\d{2})',  # 15:30
            r'(\d{1,2})\.(\d{2})',  # 15.30
            r'–≤ (\d{1,2})',  # –≤ 15
        ]
        
        hour = 12  # Default hour
        minute = 0  # Default minute
        
        for pattern in time_patterns:
            match = re.search(pattern, text)
            if match:
                try:
                    hour = int(match.group(1))
                    minute = int(match.group(2)) if len(match.groups()) > 1 else 0
                    
                    if 0 <= hour <= 23 and 0 <= minute <= 59:
                        break
                except (ValueError, IndexError):
                    continue
        
        # Determine date
        event_date = self._determine_date(text_lower)
        return event_date.replace(hour=hour, minute=minute, second=0, microsecond=0)
    
    def _determine_date(self, text_lower: str):
        """Determine date from text"""
        from datetime import datetime, timedelta
        
        now = datetime.now()
        
        # Today
        if any(word in text_lower for word in ["—Å–µ–≥–æ–¥–Ω—è", "—Å–µ–π—á–∞—Å"]):
            return now
        
        # Tomorrow
        if "–∑–∞–≤—Ç—Ä–∞" in text_lower:
            return now + timedelta(days=1)
        
        # Specific dates
        if "27.09" in text_lower or "27 —Å–µ–Ω—Ç—è–±—Ä—è" in text_lower:
            return now.replace(month=9, day=27, hour=12, minute=0, second=0, microsecond=0)
        
        # Weekdays
        weekdays = {
            "–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫": 0, "–≤—Ç–æ—Ä–Ω–∏–∫": 1, "—Å—Ä–µ–¥–∞": 2, "—á–µ—Ç–≤–µ—Ä–≥": 3,
            "–ø—è—Ç–Ω–∏—Ü–∞": 4, "—Å—É–±–±–æ—Ç–∞": 5, "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ": 6
        }
        
        for day, day_num in weekdays.items():
            if day in text_lower:
                days_ahead = day_num - now.weekday()
                if days_ahead <= 0:
                    days_ahead += 7
                return now + timedelta(days=days_ahead)
        
        # Default: tomorrow
        return now + timedelta(days=1)
    
    def run(self):
        """Run the bot"""
        # Create application
        application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
        
        # Add handlers
        application.add_handler(CommandHandler("start", self.start_command))
        application.add_handler(CommandHandler("help", self.help_command))
        
        # Handle audio and voice messages
        application.add_handler(MessageHandler(filters.VOICE | filters.AUDIO, self.handle_audio_message))
        
        # Handle text messages
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_text_message))
        
        # Start the bot
        logger.info("Starting Command Telegram Bot...")
        application.run_polling()

if __name__ == "__main__":
    bot = CommandTelegramBot()
    bot.run()
